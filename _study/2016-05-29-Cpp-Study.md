### 가상 함수 테이블

#### 가상 함수 테이블 생성

* 객체를 생성할 때, 가상 테이블이 만들어진다. - 생성자가 호출되기 전에 만들어진다.
* 객체가 생성되지 않으면 가상 테이블이 만들어지지지 않는다.
* 가상함수 테이블은 fix 된 것이 아니다. 생성하면서 계속 바뀐다.


#### 참조

* 참조는 객체를 만들지 않는다.

#### 가상 함수 테이블 호출

* 검색에 대한 비용이 들어간다.
* 자바처럼 gc을 사용하는 언어는 모든 함수가 가상함수이다. - 검색 비용이 항상 발생한다.
* 검색 비용을 0로 만드는 기술 - C++의 템플릿을 사용 - 정적 바인딩

#### 가상 함수 테이블

* 가상 함수 테이블은 어디에 만들어지는가?
* 메모리에 생성된다. : 가상함수를 가지는 클래스의 경우 가상 함수 테이블을 가르키기 위한 포인터가 하나 더 생긴다. sizeof()를 하면 4바이트가 추가된다. 

* 가상 함수 테이블을 가르키는 포인터의 위치는 접근 제한이 변하는 위치 또는 시작점, 끝점에 넣을 수 있도록 허용된다. 

```
class A {
private:
	int a_;		// value representation
public:
	int b_;		// value representation
	
	// ??? 		// object representation
public:
	virtual void test() {
		std::cout << "test" << std::endl;
	}
}
```

* 중요한 이유 : 동적 다형성 - 시간, 공간, 물리적인 부분을 무시하고 파생 클래스가 부모 클래스의 일부 기능을 구현함을 알 수 있다.
	* 규약을 미리 정의하고, 규약을 따르는 컨텐츠는 따로 구현할 수 있다. 
	* 웹 브라우저도 따지고 보면 이런 방식이다. 
	
* 템플릿 : 파생 클래스가 만들어지는 순간에 자신도 만들어진다. 
	* 자식이 만들어지는 순간에 부모도 자식을 알게 되는 개념이다(?)

#### pod

* plain of data
* 모든 것이 값인 경우 : 가상 함수가 없는 structure - 접근 제한이 변하는 곳이 없다(?)

#### override 키워드

* 파생 클래스에서는 virtual 키워드 보다는 override 라는 키워드를 사용하는 것이 좋다.

#### 언어의 표현력

* 템플릿 메타 프로그래밍, 함수형 프로그래밍 <--> 가상 함수 테이블

#### final 키워드

* 더이상 파생 클래스의 가상 함수를 재정의할 수 없도록 한다. : override 를 불가능하게 한다는 의미이다. 따라서 override 한 함수에만 사용할 수 있다.

#### 가상 소멸자

* 맨 처음 클래스의 소멸자를 virtual 함수로 만들면, 모든 파생 클래스의 소멸자도 virtual이 된다.
* 소멸할 때도 가상 함수 테이블을 사용한다.

### 순수 가상 함수

#### 추상 클래스 타입

* 순수 가상 함수를 하나라도 가지면, 인스턴스를 만들 수 없으므로, abstract (class) type 이라고 한다.

* 추상 클래스를 파생하여 구현한 객체는 Implementation 을 담당하게 된다. : realization (실체화) - 추상 클래스 : virtualization (추상화?) - Interface 상속이라고 한다.

#### 동종의 클래스

* 구현 상속일 경우에는 동종의 클래스가 된다. : generalization (일반화) - 파생 클래스 : specialization (특수화)

### NVI 패턴

* NVI : Non Virtual Interface

### <windows.h>

* 윈도우즈 운영체제에서는 사용해줘야 한다.
* GetStdHandle(...) : windows.h 과 관련이 있을 것이다(?)

### 예외 처리

* uncatched 상태를 거치게 된다.
* smart pointer가 만들어져서 wrapping 이 이루어진다. 
	* reference count가 발생한다. 
	* 예외 처리 구문에서 다시 예외를 발생시킬 수 있다.
	* exception_err : 예외 객체 
	
	```
	auto ptr = std::current_exception();
	std::rethrow_exception(ptr);		// async() 등에서 많이 사용한다.
	```
#### 예외와 에러의 차이

* 예외 : 발생한 곳과 처리할 곳이 분리되어 있기 때문에 사용한다.
	* 에러 : 발생한 곳에서 처리할 수 있거나 안한 것이다.  
	* 예외 : 발생한 곳에서는 처리할 수 없는 경우에 해당한다.

* continental value(?) : 여러 의미로 해석될 수 있는 값

* `catch` : exception handler - 여기로 오면 catched 상태가 된다. 

* 에러를 던지는 경우에는 `try` 구문내의 객체들은 소멸되고 나서 던져진다.
	* 소멸자가 에러를 발생하면 안된다.
	* 생성자는 에러를 발생해도 된다(?)

#### Optional 타입

* `optional` : 17spec에 추가됨. 예외 발생할 때 리턴 타입을 2가지로 주는 개념과 비슷하다. 값이 있는 경우와 없는 경우로 나눠서 리턴한다.

#### catch 구문의 순서 

* 여러개의 예외를 처리할 때는 특수화된 catch 구문이 먼저 나와야 한다.
* `catch(...)` : 모든 예외를 처리할 수 있다. - 따라서 마지막에 나와야 한다.

#### function try 구문

* 함수 본체에 try 구문을 적용할 수 있다. 

```
int function() 
try {
	...				// 가능한 표기법
}
catch(...) {
} 

* 생성자도 try 구문 적용할 수 있다. - 멤버 초기화 과정에서 발생하는 예외를 처리하려면 사용해야 한다.

```
Constructor(int temp)
try : some(temp) {				// 가능한 표기법
}
catch(...) {
}
```

#### 예외 클래스

* 조건 : copyable 해야 된다. - 복사 생성자가 있어야 한다. 없으면 기본 복사 생성자가 생긴다. 







